# Coding Assessment CSharp
 
## Background
This assessment was created using a Windows 11 virtual machine on my Linux desktop. A MySQL database, called "products", is hosted locally and contains a table called "products_list". Here, product codes, names, and prices are stored. The program was developed using Visual Studio as a console app and written in C#.

## How it works
This program takes an object oriented approach to a shopping cart by defining different classes for different features throughout the program. The main process handles the core loop for displaying information in the console and gathering user input. The code is throughly commented to explain the process line by line, but the overall synopsis is below.

When the program begins, it starts an initilization process that establishes a connection to a database, in this instance the "products" database, and stores this connection in a DatabaseConnection object. This object is used to house all database related functions, and manage our actual connection and queries for the connected database. A DatabaseConnection is initialized with all required information for the connection, including the server name, user ID, password, and database name. The two provided functions of a DatabaseConnection, ConnectToDatabase and GetTableData, are called in that order in the main process, to establish this DatabaseConnection's connection and subsequently perform a query on a table in the database. The DatabaseConnection also has error handling for if a connection fails or times out from taking too long to connect.

Once a connection is established, the GetTableData function on our new DatabaseConnection provides us with a dataset containing information from the query in a format viable to be read as a table, List<List<string>>. This format is chosen as it visually can be represented as a 2D array, or a grid, which will be used later. In this instance, the query run on our DatabaseConnection selects all products from a table called "products_list" and gives back a List<List<string>>.

Now that the table data is loaded, the products in this table get converted to Product objects, as these data containers store the name, code, and price of each object. These objects will later be added to our cart to perform math calculations and display more information.

Now that we have our database connection and all our products, the program is initialized and ready to start processing our shopping. I added the requirement of pressing a key after initialization just as a safety measure to ensure all initialization steps are completed properly.

Once started, the first thing that happens is a new cart is created. The cart is a Cart object which houses all operations and data for our customer's cart. This gets created right before our main loop where all input is handled, so any changes get committed and remain in the same cart. Carts have dictionaries for their products which use the product as a key and the number of items as a value. This list of products is used across all functions in the cart, which provide access to calculating the subtotal, discounts, shipping, and total of the created cart, and more that will be used later.

Finally, the last setup step is initializing all of the tables used in the program, namely the Products, Cart, and Prices tables. The tables themselves will be explained below, but they are stored in Dictionary using the table name as a key and a table object as the value. Since the Product table has a special table type, the ProductTable, which inherits from the Table class, it gets added to this dictionary alongside the other base Table objects.

Now that everything is set up, the loop starts and the full list of products is displayed using a table, which is a dynamic, reusable object type that can generate strings to be printed to the console using a set of data in a table format. This is where the List<List<string>> comes in, as the table uses this dataset to create rows and columns of data and automatically formats it as a table, calculating the appropriate spacing for columns based on entry length and allowing for extra padding to be added per table.

The first table presented, the products list, is a specialized type of Table called a ProductTable, which inherits from the Table class and has a helper function specifically to translate a list of products into a List<List<string>> as a shortcut, which then gives back a string containing the table to be printed to the console. The next two tables are base Tables and are conditional, as they only show when items are in the cart. First conditional table is for the contents of our cart. Carts have a function, GetCartContentsInTableFormat, that can output their contents in the List<List<string>> format, and this is used to output a table of our cart's contents only if our cart has products in it. The second conditional table shows all prices relevant to our cart, meaning the subtotal, discounts, shipping price, and total price. Carts also have a function similar to GetCartContentsInTableFormat, GetCartPriceInTableFormat, which outputs a List<List<string>> of these numberical values after performing these calculations internally.

Finally, the last thing needed is to simply get the user's input, and the way this is handled is by having the user first enter the product code they want to add to the cart, followed by the number of this product they want to add. Input validation ensures they entered a valid product code and integer before using the cart's AddProduct function to add the selected product and quantity to the cart's dictionary.

After this the loop happens again, and now that changes have been committed to the cart, when the loops runs again, the cart table and price table now display. Every time the user adds products or clears the cart, the entire console and all tables are redrawn using any changed data. 

Test results using the example cart data are stored in the Test Results directory, and all object classes are in the scripts directory. The main concepts of using OOP and the 4 pillars are represented here as much as possible. Each class acts as an encapsulation of all features specific to the object type, such as the cart having funcitons to add to the cart, get its subtotal, etc. The specialized ProductTable inherits from the regular Table class because it still needs to generate a table and uses the table's padding value, but has a special function to create the table using a list of products, which also acts as a polymorphic relation between the two. The main process only needs to create these objects and manage them using the functions provided in the objects themselves; In no way does it need to make direct changes to any values in the object itself. This is best seen with the Cart, where certain functions are private/abstracted and only used internally in the cart, which functions such as GetCartContentsInTableFormat are public and used visibly by the program.